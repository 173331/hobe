-- ====================== AUTO WALK RECORDER (SIMPLE) ======================
-- Record movement + animations, playback with loop
-- ==========================================================================

local Player = game.Players.LocalPlayer
local PlayerGui = Player:WaitForChild("PlayerGui")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")

-- ================= STORAGE =================
local recordings = {}
local STORAGE_FILE = "autowalk_recordings.txt"

local function serializeCFrame(cf)
	local p = cf.Position
	local rx, ry, rz = cf:ToOrientation()
	return string.format("%.2f,%.2f,%.2f,%.4f,%.4f,%.4f", p.X, p.Y, p.Z, rx, ry, rz)
end

local function parseCFrame(str)
	local parts = string.split(str, ",")
	local pos = Vector3.new(tonumber(parts[1]), tonumber(parts[2]), tonumber(parts[3]))
	return CFrame.new(pos) * CFrame.fromOrientation(tonumber(parts[4]), tonumber(parts[5]), tonumber(parts[6]))
end

local function saveRecordings()
	local data = HttpService:JSONEncode(recordings)
	writefile(STORAGE_FILE, data)
	print("‚úÖ Saved " .. #recordings .. " recording(s)")
end

local function loadRecordings()
	if not isfile or not readfile then return end
	if not isfile(STORAGE_FILE) then return end
	
	local success, data = pcall(function()
		return readfile(STORAGE_FILE)
	end)
	
	if success and data then
		recordings = HttpService:JSONDecode(data)
		print("‚úÖ Loaded " .. #recordings .. " recording(s)")
	end
end

-- ================= RECORDER =================
local Recorder = {}
Recorder.__index = Recorder

function Recorder.new(char)
	local hrp = char:FindFirstChild("HumanoidRootPart")
	local humanoid = char:FindFirstChild("Humanoid")
	
	return setmetatable({
		char = char,
		root = hrp,
		humanoid = humanoid,
		hipHeight = humanoid and humanoid.HipHeight or 0,
		frames = {},
		animationIds = {},
		startTime = 0,
		conn = nil
	}, Recorder)
end

function Recorder:start()
	self.frames = {}
	self.animationIds = {}
	self.startTime = tick()
	
	-- Capture animations
	if self.humanoid then
		local animator = self.humanoid:FindFirstChildOfClass("Animator")
		if animator then
			for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
				local animId = track.Animation.AnimationId
				local numId = animId:match("%d+")
				if numId then
					table.insert(self.animationIds, tonumber(numId))
					print("üìπ Recording animation: " .. numId)
				end
			end
		end
	end
	
	-- Record frames
	self.conn = RunService.Heartbeat:Connect(function()
		if self.root then
			local elapsed = tick() - self.startTime
			table.insert(self.frames, {
				cframe = self.root.CFrame,
				timestamp = elapsed
			})
		end
	end)
	
	print("üî¥ Recording started")
end

function Recorder:stop()
	if self.conn then self.conn:Disconnect() end
	print("‚èπÔ∏è Recording stopped: " .. #self.frames .. " frames")
	return {
		frames = self.frames,
		hipHeight = self.hipHeight,
		animationIds = self.animationIds
	}
end

-- ================= PLAYBACK =================
local Playback = {}
Playback.__index = Playback

function Playback.new(char, recording)
	local hrp = char:FindFirstChild("HumanoidRootPart")
	local humanoid = char:FindFirstChild("Humanoid")
	
	return setmetatable({
		char = char,
		root = hrp,
		humanoid = humanoid,
		recording = recording,
		index = 1,
		startTime = 0,
		active = false,
		loop = false,
		conn = nil,
		anims = {}
	}, Playback)
end

function Playback:start()
	if not self.recording or not self.recording.frames or #self.recording.frames == 0 then
		warn("‚ùå No recording to play")
		return
	end
	
	self.active = true
	self.index = 1
	self.startTime = tick()
	
	-- Load animations
	if self.humanoid and self.recording.animationIds and #self.recording.animationIds > 0 then
		local ids = self.recording.animationIds
		
		-- Create animation objects
		local runAnim = Instance.new("Animation")
		runAnim.AnimationId = "rbxassetid://" .. ids[1]
		self.anims.run = self.humanoid:LoadAnimation(runAnim)
		
		if ids[2] then
			local jumpAnim = Instance.new("Animation")
			jumpAnim.AnimationId = "rbxassetid://" .. ids[2]
			self.anims.jump = self.humanoid:LoadAnimation(jumpAnim)
		end
		
		print("‚úÖ Loaded animations")
	end
	
	-- Disable controls
	if self.humanoid then
		self.humanoid.WalkSpeed = 0
		self.humanoid.AutoRotate = false
	end
	
	-- Play animation
	if self.anims.run then
		self.anims.run:Play()
	end
	
	-- Playback loop
	self.conn = RunService.Heartbeat:Connect(function()
		if not self.active or not self.root then return end
		
		local elapsed = tick() - self.startTime
		local frames = self.recording.frames
		
		-- Find current frame
		while self.index <= #frames and frames[self.index].timestamp < elapsed do
			self.index = self.index + 1
		end
		
		-- End of recording
		if self.index > #frames then
			if self.loop then
				-- Restart
				self.index = 1
				self.startTime = tick()
				print("üîÅ Loop restart")
			else
				self:stop()
			end
			return
		end
		
		-- Apply frame
		if self.index <= #frames then
			self.root.CFrame = frames[self.index].cframe
		end
	end)
	
	print("‚ñ∂Ô∏è Playback started")
end

function Playback:stop()
	self.active = false
	if self.conn then self.conn:Disconnect() end
	
	-- Stop animations
	for _, anim in pairs(self.anims) do
		pcall(function() anim:Stop() end)
	end
	
	-- Restore controls
	if self.humanoid then
		self.humanoid.WalkSpeed = 16
		self.humanoid.AutoRotate = true
	end
	
	print("‚èπÔ∏è Playback stopped")
end

-- ================= SYSTEM =================
local System = {
	state = "idle",
	recorder = nil,
	playback = nil
}

function System:startRecording()
	self:stop()
	self.recorder = Recorder.new(Player.Character)
	self.recorder:start()
	self.state = "recording"
end

function System:stopRecording()
	if not self.recorder then return nil end
	local data = self.recorder:stop()
	self.recorder = nil
	self.state = "idle"
	return data
end

function System:startPlayback(recording, loop)
	self:stop()
	self.playback = Playback.new(Player.Character, recording)
	self.playback.loop = loop or false
	self.playback:start()
	self.state = "playing"
end

function System:stop()
	if self.recorder then
		self.recorder:stop()
		self.recorder = nil
	end
	if self.playback then
		self.playback:stop()
		self.playback = nil
	end
	self.state = "idle"
end

-- ================= UI =================
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "AutoWalkSimple"
screenGui.ResetOnSpawn = false
screenGui.Parent = PlayerGui

local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0, 250, 0, 350)
mainFrame.Position = UDim2.new(0.05, 0, 0.1, 0)
mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
mainFrame.BackgroundTransparency = 0.1
mainFrame.BorderSizePixel = 0
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Parent = screenGui
Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 10)

local title = Instance.new("TextLabel", mainFrame)
title.Size = UDim2.new(1, 0, 0, 35)
title.BackgroundTransparency = 1
title.Text = "Auto Walk"
title.TextColor3 = Color3.new(1, 1, 1)
title.Font = Enum.Font.GothamBold
title.TextSize = 16

-- Status
local status = Instance.new("TextLabel", mainFrame)
status.Size = UDim2.new(1, -20, 0, 25)
status.Position = UDim2.new(0, 10, 0, 40)
status.BackgroundTransparency = 1
status.Text = "Status: Idle"
status.TextColor3 = Color3.fromRGB(200, 200, 200)
status.Font = Enum.Font.Gotham
status.TextSize = 12

-- Record button
local recordBtn = Instance.new("TextButton", mainFrame)
recordBtn.Size = UDim2.new(0, 110, 0, 35)
recordBtn.Position = UDim2.new(0, 10, 0, 70)
recordBtn.BackgroundColor3 = Color3.fromRGB(220, 50, 50)
recordBtn.Text = "üî¥ Record"
recordBtn.TextColor3 = Color3.new(1, 1, 1)
recordBtn.Font = Enum.Font.GothamBold
recordBtn.TextSize = 13
Instance.new("UICorner", recordBtn).CornerRadius = UDim.new(0, 8)

-- Stop button
local stopBtn = Instance.new("TextButton", mainFrame)
stopBtn.Size = UDim2.new(0, 110, 0, 35)
stopBtn.Position = UDim2.new(0, 130, 0, 70)
stopBtn.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
stopBtn.Text = "‚èπÔ∏è Stop"
stopBtn.TextColor3 = Color3.new(1, 1, 1)
stopBtn.Font = Enum.Font.GothamBold
stopBtn.TextSize = 13
Instance.new("UICorner", stopBtn).CornerRadius = UDim.new(0, 8)

-- Save button
local saveBtn = Instance.new("TextButton", mainFrame)
saveBtn.Size = UDim2.new(1, -20, 0, 35)
saveBtn.Position = UDim2.new(0, 10, 0, 115)
saveBtn.BackgroundColor3 = Color3.fromRGB(50, 150, 50)
saveBtn.Text = "üíæ Save"
saveBtn.TextColor3 = Color3.new(1, 1, 1)
saveBtn.Font = Enum.Font.GothamBold
saveBtn.TextSize = 13
Instance.new("UICorner", saveBtn).CornerRadius = UDim.new(0, 8)

-- Recordings list
local listLabel = Instance.new("TextLabel", mainFrame)
listLabel.Size = UDim2.new(1, -20, 0, 20)
listLabel.Position = UDim2.new(0, 10, 0, 160)
listLabel.BackgroundTransparency = 1
listLabel.Text = "Recordings:"
listLabel.TextColor3 = Color3.new(1, 1, 1)
listLabel.Font = Enum.Font.GothamBold
listLabel.TextSize = 11
listLabel.TextXAlignment = Enum.TextXAlignment.Left

local listScroll = Instance.new("ScrollingFrame", mainFrame)
listScroll.Size = UDim2.new(1, -20, 0, 160)
listScroll.Position = UDim2.new(0, 10, 0, 180)
listScroll.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
listScroll.BorderSizePixel = 0
listScroll.ScrollBarThickness = 4
Instance.new("UICorner", listScroll).CornerRadius = UDim.new(0, 8)

local listLayout = Instance.new("UIListLayout", listScroll)
listLayout.Padding = UDim.new(0, 5)

-- ================= LOGIC =================
local currentRecording = nil

local function updateStatus()
	if System.state == "recording" then
		status.Text = "Status: üî¥ Recording..."
		status.TextColor3 = Color3.fromRGB(220, 50, 50)
	elseif System.state == "playing" then
		status.Text = "Status: ‚ñ∂Ô∏è Playing..."
		status.TextColor3 = Color3.fromRGB(50, 150, 50)
	else
		status.Text = "Status: Idle"
		status.TextColor3 = Color3.fromRGB(200, 200, 200)
	end
end

local function refreshList()
	for _, child in ipairs(listScroll:GetChildren()) do
		if child:IsA("Frame") then child:Destroy() end
	end
	
	for i, rec in ipairs(recordings) do
		local item = Instance.new("Frame", listScroll)
		item.Size = UDim2.new(1, -10, 0, 35)
		item.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
		item.BorderSizePixel = 0
		Instance.new("UICorner", item).CornerRadius = UDim.new(0, 6)
		
		local label = Instance.new("TextLabel", item)
		label.Size = UDim2.new(1, -80, 1, 0)
		label.Position = UDim2.new(0, 5, 0, 0)
		label.BackgroundTransparency = 1
		label.Text = rec.name
		label.TextColor3 = Color3.new(1, 1, 1)
		label.Font = Enum.Font.Gotham
		label.TextSize = 11
		label.TextXAlignment = Enum.TextXAlignment.Left
		
		local playBtn = Instance.new("TextButton", item)
		playBtn.Size = UDim2.new(0, 30, 0, 25)
		playBtn.Position = UDim2.new(1, -70, 0.5, -12.5)
		playBtn.BackgroundColor3 = Color3.fromRGB(50, 150, 50)
		playBtn.Text = "‚ñ∂"
		playBtn.TextColor3 = Color3.new(1, 1, 1)
		playBtn.Font = Enum.Font.GothamBold
		playBtn.TextSize = 12
		Instance.new("UICorner", playBtn).CornerRadius = UDim.new(0, 4)
		
		local loopBtn = Instance.new("TextButton", item)
		loopBtn.Size = UDim2.new(0, 30, 0, 25)
		loopBtn.Position = UDim2.new(1, -35, 0.5, -12.5)
		loopBtn.BackgroundColor3 = Color3.fromRGB(100, 100, 200)
		loopBtn.Text = "üîÅ"
		loopBtn.TextColor3 = Color3.new(1, 1, 1)
		loopBtn.Font = Enum.Font.GothamBold
		loopBtn.TextSize = 12
		Instance.new("UICorner", loopBtn).CornerRadius = UDim.new(0, 4)
		
		playBtn.MouseButton1Click:Connect(function()
			System:startPlayback(rec, false)
			updateStatus()
		end)
		
		loopBtn.MouseButton1Click:Connect(function()
			System:startPlayback(rec, true)
			updateStatus()
		end)
	end
	
	listScroll.CanvasSize = UDim2.new(0, 0, 0, listLayout.AbsoluteContentSize.Y + 10)
end

-- Button events
recordBtn.MouseButton1Click:Connect(function()
	System:startRecording()
	updateStatus()
end)

stopBtn.MouseButton1Click:Connect(function()
	if System.state == "recording" then
		currentRecording = System:stopRecording()
		print("‚úÖ Recording ready to save")
	else
		System:stop()
	end
	updateStatus()
end)

saveBtn.MouseButton1Click:Connect(function()
	if not currentRecording then
		warn("‚ö†Ô∏è No recording to save")
		return
	end
	
	local name = "rec_" .. os.date("%H%M%S")
	currentRecording.name = name
	table.insert(recordings, currentRecording)
	saveRecordings()
	refreshList()
	currentRecording = nil
	print("‚úÖ Saved: " .. name)
end)

-- ================= STARTUP =================
print("=== AUTO WALK RECORDER (SIMPLE) ===")
print("‚úÖ Recording with animations")
print("‚úÖ Playback with loop")
print("====================================")

loadRecordings()
refreshList()
updateStatus()
