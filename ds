-- ====================== AUTO WALK RECORDER (SIMPLE) ======================
-- Record movement + animations, playback with loop
-- ==========================================================================

print("üöÄ Script starting...")

local Player = game.Players.LocalPlayer
local PlayerGui = Player:WaitForChild("PlayerGui")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")

print("‚úÖ Services loaded")

-- ================= STORAGE =================
local recordings = {}

local function saveRecordings()
	-- In-memory only (no file save)
	print("‚úÖ Saved " .. #recordings .. " recording(s) in memory")
end

local function loadRecordings()
	-- No file loading, start fresh
	print("‚úÖ Ready to record")
end

-- ================= RECORDER =================
local Recorder = {}
Recorder.__index = Recorder

function Recorder.new(char)
	local hrp = char:FindFirstChild("HumanoidRootPart")
	local humanoid = char:FindFirstChild("Humanoid")
	
	return setmetatable({
		char = char,
		root = hrp,
		humanoid = humanoid,
		hipHeight = humanoid and humanoid.HipHeight or 0,
		frames = {},
		animationIds = {},
		startTime = 0,
		conn = nil
	}, Recorder)
end

function Recorder:start()
	self.frames = {}
	self.animationIds = {}
	self.startTime = tick()
	
	-- Record frames with current animation state
	self.conn = RunService.Heartbeat:Connect(function()
		if self.root then
			local elapsed = tick() - self.startTime
			
			-- Get current playing animation
			local currentAnimId = nil
			if self.humanoid then
				local animator = self.humanoid:FindFirstChildOfClass("Animator")
				if animator then
					local tracks = animator:GetPlayingAnimationTracks()
					if #tracks > 0 then
						-- Get the first playing animation
						local animId = tracks[1].Animation.AnimationId
						local numId = animId:match("%d+")
						if numId then
							currentAnimId = tonumber(numId)
						end
					end
				end
			end
			
			table.insert(self.frames, {
				cframe = self.root.CFrame,
				timestamp = elapsed,
				animId = currentAnimId  -- Store animation per frame
			})
		end
	end)
	
	print("üî¥ Recording started (with animations per frame)")
end

function Recorder:stop()
	if self.conn then self.conn:Disconnect() end
	
	-- Collect unique animation IDs
	local uniqueAnims = {}
	local animSet = {}
	for _, frame in ipairs(self.frames) do
		if frame.animId and not animSet[frame.animId] then
			table.insert(uniqueAnims, frame.animId)
			animSet[frame.animId] = true
		end
	end
	
	print("‚èπÔ∏è Recording stopped: " .. #self.frames .. " frames, " .. #uniqueAnims .. " unique animations")
	return {
		frames = self.frames,
		hipHeight = self.hipHeight,
		animationIds = uniqueAnims
	}
end

-- ================= PLAYBACK =================
local Playback = {}
Playback.__index = Playback

function Playback.new(char, recording)
	local hrp = char:FindFirstChild("HumanoidRootPart")
	local humanoid = char:FindFirstChild("Humanoid")
	
	return setmetatable({
		char = char,
		root = hrp,
		humanoid = humanoid,
		recording = recording,
		index = 1,
		startTime = 0,
		active = false,
		loop = false,
		conn = nil,
		anims = {}
	}, Playback)
end

function Playback:start()
	if not self.recording or not self.recording.frames or #self.recording.frames == 0 then
		warn("‚ùå No recording to play")
		return
	end
	
	self.active = true
	self.index = 1
	self.startTime = tick()
	
	-- Load all unique animations
	if self.humanoid and self.recording.animationIds and #self.recording.animationIds > 0 then
		for _, animId in ipairs(self.recording.animationIds) do
			local anim = Instance.new("Animation")
			anim.AnimationId = "rbxassetid://" .. animId
			self.anims[animId] = self.humanoid:LoadAnimation(anim)
		end
		print("‚úÖ Loaded " .. #self.recording.animationIds .. " animations")
	end
	
	-- Disable controls
	if self.humanoid then
		self.humanoid.WalkSpeed = 0
		self.humanoid.AutoRotate = false
	end
	
	local currentPlayingAnim = nil
	
	-- Playback loop
	self.conn = RunService.Heartbeat:Connect(function()
		if not self.active or not self.root then return end
		
		local elapsed = tick() - self.startTime
		local frames = self.recording.frames
		
		-- Find current frame
		while self.index <= #frames and frames[self.index].timestamp < elapsed do
			self.index = self.index + 1
		end
		
		-- End of recording
		if self.index > #frames then
			if self.loop then
				self.index = 1
				self.startTime = tick()
				print("üîÅ Loop restart")
			else
				self:stop()
			end
			return
		end
		
		-- Apply frame
		if self.index <= #frames then
			local frame = frames[self.index]
			self.root.CFrame = frame.cframe
			
			-- Play animation for this frame
			if frame.animId and self.anims[frame.animId] then
				if currentPlayingAnim ~= frame.animId then
					-- Stop previous animation
					if currentPlayingAnim and self.anims[currentPlayingAnim] then
						self.anims[currentPlayingAnim]:Stop()
					end
					-- Play new animation
					self.anims[frame.animId]:Play()
					currentPlayingAnim = frame.animId
				end
			end
		end
	end)
	
	print("‚ñ∂Ô∏è Playback started")
end

function Playback:stop()
	self.active = false
	if self.conn then self.conn:Disconnect() end
	
	-- Stop animations
	for _, anim in pairs(self.anims) do
		pcall(function() anim:Stop() end)
	end
	
	-- Restore controls
	if self.humanoid then
		self.humanoid.WalkSpeed = 16
		self.humanoid.AutoRotate = true
	end
	
	print("‚èπÔ∏è Playback stopped")
end

-- ================= SYSTEM =================
local System = {
	state = "idle",
	recorder = nil,
	playback = nil
}

function System:startRecording()
	self:stop()
	self.recorder = Recorder.new(Player.Character)
	self.recorder:start()
	self.state = "recording"
end

function System:stopRecording()
	if not self.recorder then return nil end
	local data = self.recorder:stop()
	self.recorder = nil
	self.state = "idle"
	return data
end

function System:startPlayback(recording, loop)
	self:stop()
	self.playback = Playback.new(Player.Character, recording)
	self.playback.loop = loop or false
	self.playback:start()
	self.state = "playing"
end

function System:stop()
	if self.recorder then
		self.recorder:stop()
		self.recorder = nil
	end
	if self.playback then
		self.playback:stop()
		self.playback = nil
	end
	self.state = "idle"
end

-- ================= UI =================
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "AutoWalkSimple"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

-- Wait for PlayerGui to be ready
repeat task.wait() until PlayerGui
screenGui.Parent = PlayerGui

local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0, 250, 0, 350)
mainFrame.Position = UDim2.new(0, 20, 0, 100)
mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
mainFrame.BackgroundTransparency = 0.1
mainFrame.BorderSizePixel = 0
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.ZIndex = 10
mainFrame.Parent = screenGui
Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 10)

local title = Instance.new("TextLabel", mainFrame)
title.Size = UDim2.new(1, 0, 0, 35)
title.BackgroundTransparency = 1
title.Text = "Auto Walk"
title.TextColor3 = Color3.new(1, 1, 1)
title.Font = Enum.Font.GothamBold
title.TextSize = 16

-- Status
local status = Instance.new("TextLabel", mainFrame)
status.Size = UDim2.new(1, -20, 0, 25)
status.Position = UDim2.new(0, 10, 0, 40)
status.BackgroundTransparency = 1
status.Text = "Status: Idle"
status.TextColor3 = Color3.fromRGB(200, 200, 200)
status.Font = Enum.Font.Gotham
status.TextSize = 12

-- Record button
local recordBtn = Instance.new("TextButton", mainFrame)
recordBtn.Size = UDim2.new(0, 110, 0, 35)
recordBtn.Position = UDim2.new(0, 10, 0, 70)
recordBtn.BackgroundColor3 = Color3.fromRGB(220, 50, 50)
recordBtn.Text = "üî¥ Record"
recordBtn.TextColor3 = Color3.new(1, 1, 1)
recordBtn.Font = Enum.Font.GothamBold
recordBtn.TextSize = 13
Instance.new("UICorner", recordBtn).CornerRadius = UDim.new(0, 8)

-- Stop button
local stopBtn = Instance.new("TextButton", mainFrame)
stopBtn.Size = UDim2.new(0, 110, 0, 35)
stopBtn.Position = UDim2.new(0, 130, 0, 70)
stopBtn.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
stopBtn.Text = "‚èπÔ∏è Stop"
stopBtn.TextColor3 = Color3.new(1, 1, 1)
stopBtn.Font = Enum.Font.GothamBold
stopBtn.TextSize = 13
Instance.new("UICorner", stopBtn).CornerRadius = UDim.new(0, 8)

-- Save button
local saveBtn = Instance.new("TextButton", mainFrame)
saveBtn.Size = UDim2.new(1, -20, 0, 35)
saveBtn.Position = UDim2.new(0, 10, 0, 115)
saveBtn.BackgroundColor3 = Color3.fromRGB(50, 150, 50)
saveBtn.Text = "üíæ Save"
saveBtn.TextColor3 = Color3.new(1, 1, 1)
saveBtn.Font = Enum.Font.GothamBold
saveBtn.TextSize = 13
Instance.new("UICorner", saveBtn).CornerRadius = UDim.new(0, 8)

-- Recordings list
local listLabel = Instance.new("TextLabel", mainFrame)
listLabel.Size = UDim2.new(1, -20, 0, 20)
listLabel.Position = UDim2.new(0, 10, 0, 160)
listLabel.BackgroundTransparency = 1
listLabel.Text = "Recordings:"
listLabel.TextColor3 = Color3.new(1, 1, 1)
listLabel.Font = Enum.Font.GothamBold
listLabel.TextSize = 11
listLabel.TextXAlignment = Enum.TextXAlignment.Left

local listScroll = Instance.new("ScrollingFrame", mainFrame)
listScroll.Size = UDim2.new(1, -20, 0, 160)
listScroll.Position = UDim2.new(0, 10, 0, 180)
listScroll.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
listScroll.BorderSizePixel = 0
listScroll.ScrollBarThickness = 4
Instance.new("UICorner", listScroll).CornerRadius = UDim.new(0, 8)

local listLayout = Instance.new("UIListLayout", listScroll)
listLayout.Padding = UDim.new(0, 5)

-- ================= LOGIC =================
local currentRecording = nil

local function updateStatus()
	if System.state == "recording" then
		status.Text = "Status: üî¥ Recording..."
		status.TextColor3 = Color3.fromRGB(220, 50, 50)
	elseif System.state == "playing" then
		status.Text = "Status: ‚ñ∂Ô∏è Playing..."
		status.TextColor3 = Color3.fromRGB(50, 150, 50)
	else
		status.Text = "Status: Idle"
		status.TextColor3 = Color3.fromRGB(200, 200, 200)
	end
end

local function refreshList()
	for _, child in ipairs(listScroll:GetChildren()) do
		if child:IsA("Frame") then child:Destroy() end
	end
	
	for i, rec in ipairs(recordings) do
		local item = Instance.new("Frame", listScroll)
		item.Size = UDim2.new(1, -10, 0, 35)
		item.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
		item.BorderSizePixel = 0
		Instance.new("UICorner", item).CornerRadius = UDim.new(0, 6)
		
		local label = Instance.new("TextLabel", item)
		label.Size = UDim2.new(1, -105, 1, 0)
		label.Position = UDim2.new(0, 5, 0, 0)
		label.BackgroundTransparency = 1
		label.Text = rec.name
		label.TextColor3 = Color3.new(1, 1, 1)
		label.Font = Enum.Font.Gotham
		label.TextSize = 11
		label.TextXAlignment = Enum.TextXAlignment.Left
		
		local playBtn = Instance.new("TextButton", item)
		playBtn.Size = UDim2.new(0, 30, 0, 25)
		playBtn.Position = UDim2.new(1, -95, 0.5, -12.5)
		playBtn.BackgroundColor3 = Color3.fromRGB(50, 150, 50)
		playBtn.Text = "‚ñ∂"
		playBtn.TextColor3 = Color3.new(1, 1, 1)
		playBtn.Font = Enum.Font.GothamBold
		playBtn.TextSize = 12
		Instance.new("UICorner", playBtn).CornerRadius = UDim.new(0, 4)
		
		local loopBtn = Instance.new("TextButton", item)
		loopBtn.Size = UDim2.new(0, 30, 0, 25)
		loopBtn.Position = UDim2.new(1, -60, 0.5, -12.5)
		loopBtn.BackgroundColor3 = Color3.fromRGB(100, 100, 200)
		loopBtn.Text = "üîÅ"
		loopBtn.TextColor3 = Color3.new(1, 1, 1)
		loopBtn.Font = Enum.Font.GothamBold
		loopBtn.TextSize = 12
		Instance.new("UICorner", loopBtn).CornerRadius = UDim.new(0, 4)
		
		local delBtn = Instance.new("TextButton", item)
		delBtn.Size = UDim2.new(0, 30, 0, 25)
		delBtn.Position = UDim2.new(1, -25, 0.5, -12.5)
		delBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
		delBtn.Text = "üóë"
		delBtn.TextColor3 = Color3.new(1, 1, 1)
		delBtn.Font = Enum.Font.GothamBold
		delBtn.TextSize = 12
		Instance.new("UICorner", delBtn).CornerRadius = UDim.new(0, 4)
		
		playBtn.MouseButton1Click:Connect(function()
			System:startPlayback(rec, false)
			updateStatus()
		end)
		
		loopBtn.MouseButton1Click:Connect(function()
			System:startPlayback(rec, true)
			updateStatus()
		end)
		
		delBtn.MouseButton1Click:Connect(function()
			table.remove(recordings, i)
			print("üóëÔ∏è Deleted: " .. rec.name)
			refreshList()
		end)
	end
	
	listScroll.CanvasSize = UDim2.new(0, 0, 0, listLayout.AbsoluteContentSize.Y + 10)
end

-- Button events
recordBtn.MouseButton1Click:Connect(function()
	System:startRecording()
	updateStatus()
end)

stopBtn.MouseButton1Click:Connect(function()
	if System.state == "recording" then
		currentRecording = System:stopRecording()
		if currentRecording and currentRecording.frames then
			print("‚úÖ Recording ready: " .. #currentRecording.frames .. " frames")
			status.Text = "‚úÖ Ready to save (" .. #currentRecording.frames .. " frames)"
			status.TextColor3 = Color3.fromRGB(50, 200, 50)
		else
			warn("‚ùå Recording failed")
			status.Text = "‚ùå Recording failed"
			status.TextColor3 = Color3.fromRGB(255, 50, 50)
		end
	else
		System:stop()
		updateStatus()
	end
end)

saveBtn.MouseButton1Click:Connect(function()
	if not currentRecording then
		warn("‚ö†Ô∏è No recording to save. Press Record first!")
		status.Text = "‚ö†Ô∏è Record first!"
		status.TextColor3 = Color3.fromRGB(255, 150, 0)
		task.wait(2)
		updateStatus()
		return
	end
	
	if not currentRecording.frames or #currentRecording.frames == 0 then
		warn("‚ö†Ô∏è Recording is empty!")
		status.Text = "‚ö†Ô∏è Empty recording!"
		status.TextColor3 = Color3.fromRGB(255, 150, 0)
		task.wait(2)
		updateStatus()
		return
	end
	
	local name = "rec_" .. os.date("%H%M%S")
	currentRecording.name = name
	table.insert(recordings, currentRecording)
	saveRecordings()
	refreshList()
	currentRecording = nil
	status.Text = "‚úÖ Saved: " .. name
	status.TextColor3 = Color3.fromRGB(50, 200, 50)
	task.wait(2)
	updateStatus()
	print("‚úÖ Saved: " .. name)
end)

-- ================= STARTUP =================
print("=== AUTO WALK RECORDER (SIMPLE) ===")
print("‚úÖ Recording with animations")
print("‚úÖ Playback with loop")
print("‚úÖ UI Created")
print("====================================")

-- Wait a bit before loading
task.wait(0.5)
loadRecordings()
refreshList()
updateStatus()

print("‚úÖ System ready!")
